\label{sec:relatedworks}

\subsection{Синтаксические анализаторы}
Синтаксический анализ или парсинг (parsing)~--- процесс сопоставления последовательности токенов (лексем) дерева разбора, называемого абстрактным синтаксическим деревом (AST).

Синтаксический анализатор или парсер (parser)~--- это программа, выполняющая синтаксический анализ.

Так же от синтаксического анализатора ожидаются сообщения обо всех выявленных ошибках, причем достаточно внятные и полные, а кроме того, умение обрабатывать обычные, часто встречающиеся ошибки и продолжать работу с оставшейся частью программы.
Имеется три основных типа синтаксических анализаторов: универсальные, восходящие и нисходящие\cite{DB}. Мы остановимся на восходящем анализе. Восходящие синтаксические анализаторы строят дерево разбора начиная с листьев (снизу) и идя к корню (вверх). Поток символов сканируется последовательно --- слева направо.

Здесь будет рассмотрен общий вид восходящего анализа типа <<перенос/свёртка>> (shift-reduce). При анализе типа перенос-свёртка для хранения символов грамматики используется стек, а для хранения остающейся непроанализированной части входной строки~--- входной буфер. На каждом шаге свёртки (reduction) определенная подстрока, соответствующая правой части продукции, заменяется на нетерминал, являющийся левой частью продукции. Основа~--- это подстрока, которая соответствует телу продукции и свертка которой представляет собой один шаг правого порождения в обратном порядке. Использование стека в анализаторе объясняется тем важным фактом, что {\it основа} всегда находится на вершине стека и никогда~--- внутри него.

LR(k)-грамматики~--- это грамматики, для которых может быть построен синтаксический анализатор, работающий по принципу переноса-свёртки.

Наиболее эффективные восходящие методы работают только с подклассами грамматик, однако некоторые из этих классов, такие как LR(k) грамматики, достаточно выразительны для описания большинства синтаксических конструкций языков программирования.
L~--- здесь означает сканирование входного потока слева направо, R~--- построение правого порождения в обратном порядке, а k --- количество предпросматриваемых лексем входного потока, необходимых для принятия решения. 

Одними из самых эффективных синтаксических анализаторов являются LR(1)\cite{LRSpeed}. LR(1)-анализатор состоит из входного буфера, выхода, стека, программы-драйвера и таблицы синтаксического анализа. Программа-драйвер одинакова для всех LR-анализаторов, от одного анализатора к другому меняются таблицы синтаксического анализа. Программа синтаксического анализатора по одному считывает символы из входного буфера. После прочтения очередного символа она обращается к управляющей таблице и совершает соответствующее действие. Процесс чтения продолжается, пока входная цепочка не закончится.

\subsection{Menhir}
Построение анализаторов LR(1) вручную достаточно трудоемкий процесс, поэтому чаще всего пользуются генераторами синтаксических анализаторов. 

Генератор синтаксических анализаторов --- это программа, которая по спецификации грамматики строит синтаксический анализатор. Одним из таких генераторов и является Menhir~\cite{ME}. Он был выбран командой Reason, как лучшая, по сравнению с ocamlyacc~\cite{ocamlyacc}, версия генераторов синтаксических анализаторов.



\subsection{Примеры ошибок}

Здесь будут приведены примеры синтаксических конструкций, в которых часто встречаются ошибки, в формате сравнения кода на OCaml и Reason соответственно.

\hfill


\begin{example}
	\begin{subexample}[b]{\textwidth}
		\lstinputlisting[frame=single,language=Caml]{examplePatternMatching.ml}
		\caption{Код OCaml}
	\end{subexample}
	\hfill
	
	\begin{subexample}[b]{\textwidth}
		\lstinputlisting[frame=single, language=Caml]{examplePatternMatching.re}
		\caption{Код Reason}
	\end{subexample}
\caption{Сопоставление с образцом}\label{l1}
\end{example}

На листинге \ref{l1} представлена конструкция сопоставления с образцом (pattern matching). Программист может перепутать оформление стрелок (-> и =>), выбрать ключевые слова из другого языка ({\it match - with} и {\it switch(-)}) или забыть поставить фигурные скобки.


\hfill


\begin{example}
%\begin{multicols}{2}
	\begin{subexample}{0.5\textwidth}
		\lstinputlisting[frame=single, language=Caml]{forloop.ml}
		\caption{Код OCaml}
	\end{subexample}
	\begin{subexample}{0.5\textwidth}
		\lstinputlisting[frame=single, language=Caml]{forloop.re}
		\caption{Код Reason}
	\end{subexample}
%\end{multicols}
\caption{Пример цикла}\label{l2}
\end{example}

На листинге \ref{l2} представлен стандартный цикл. Человек может вместо фигурных скобок заключать тело цикла в {\it do} и {\it done}, неправильно инициализировать переменную ({\it i = 1} и {\it i in 1}) или забыть фигурные скобки после {\it for}.


\hfill


\begin{example}
%\begin{multicols}{2}
	\begin{subexample}{0.5\textwidth}
		\lstinputlisting[frame=single, language=Caml]{record.ml}
		\caption{Код OCaml}
	\end{subexample}
	\begin{subexample}{0.5\textwidth}
		\lstinputlisting[frame=single, language=Caml]{record.re}
		\caption{Код Reason}
	\end{subexample}
%\end{multicols}
\caption{Пример записи}\label{l3}
\end{example}

На листинге \ref{l3} приведено описание типа, называемого записью. В первом случае поля отделяются точкой с запятой, во втором случае просто запятой.

\subsection{Merlin}

Проект \merlin{}\cite{mer} является частью реализации сервера для анализа языка \OCaml{} (language server). Чаще всего он подключается к редакторам текста с помощью различных расширений этих редакторов, чтобы разработчик мог использовать редактор как современную интегрированную среду разработки (IDE), т.\,е. пользоваться переходом к определению объявленных имен, автодополнением и т.\,п. На данный момент в исходном коде \ReasonML{} имеется расширение для \merlin{}, которое позволяет использовать \merlin{} не только для редактирования кода на \OCaml{}, но и на \ReasonML{}.

В контексте данной работы выглядит интересной задача тесной интеграции синтаксического анализатора с проектом \merlin{}, а именно добавление возможности быстрого исправления кода, написанного со смешением двух языков, на правильный код на \ReasonML{} или \OCaml{}.


%\subsection{Реализация дополнительных правил}

